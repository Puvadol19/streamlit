# -*- coding: utf-8 -*-
"""ok check crypto DATA Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18D1c2uyGJJvFIHVLnsDQibuehsSVPZRh
"""

!pip install python-binance

!pip install ccxt

!pip install ta

!pip install mpl_finance

# Commented out IPython magic to ensure Python compatibility.
!wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz
!tar -xzvf ta-lib-0.4.0-src.tar.gz
# %cd ta-lib
!./configure --prefix=/usr
!make
!make install
!pip install Ta-Lib
import talib

!pip install vectorbt

!pip install streamlit

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# import ccxt
# import pandas as pd
# import numpy as np
# import logging
# from ta.trend import EMAIndicator
# from ta.trend import ADXIndicator
# from smtplib import SMTP
# import matplotlib.pyplot as plt
# from matplotlib.lines import Line2D
# from pandas_datareader import data
# from collections import Counter
# from mpl_finance import candlestick_ohlc
# from statistics import mean
# import math
# import talib as ta
# from talib.abstract import *
# from binance.client import Client
# import time
# import vectorbt as vbt
# import warnings
# warnings.simplefilter(action='ignore')
# vbt.settings.set_theme('dark')
# 
# plt.style.use('classic')
# logging.disable(logging.ERROR)
# 
# 
# 
# def SMAfunc(data, sma_period):
#     ser = pd.Series(data)
#     ma = ser.rolling(sma_period).mean()
#     smas = pd.Series(ma).fillna(method="bfill").values
#     return smas
# 
# def EMAfunc(data, ema_period):
#     ser = pd.Series(data)
#     ma = ser.ewm(span=ema_period, adjust=False).mean()
#     emas = pd.Series(ma).fillna(method='bfill').values
#     return emas
# 
# def RSIfunc(data, rsi_period=14):
#     delta = pd.Series(data).diff()
#     gain = delta.mask(delta<0, 0)
#     loss = delta.mask(delta>0, 0)
#     avg_gain = gain.ewm(com=rsi_period-1,min_periods=rsi_period).mean()
#     avg_loss = loss.ewm(com=rsi_period-1,min_periods=rsi_period).mean()
#     rs = abs(avg_gain/avg_loss)
#     rsi = pd.Series(100 - (100/(1+rs))).fillna(method='bfill').values
#     return rsi
# 
# 
# 
# def bollinger_band(data, bb_period=20, mult=2):
#     ser = pd.Series(data)
#     ma = ser.rolling(bb_period).mean()
#     std = ser.rolling(bb_period).std()
#     lower = pd.Series(ma - mult*std).fillna(method='bfill').values
#     mid = pd.Series(ma).fillna(method='bfill').values
#     upper = pd.Series(ma + mult*std).fillna(method='bfill').values
#     return upper, mid, lower
# 
# 
# 
# def StochOSC(close, low, high, n=13): 
#     ser_close = pd.Series(close)
#     ser_low = pd.Series(low)
#     ser_high = pd.Series(high)
#     STOK = ((ser_close - ser_low.rolling(n).min()) / (ser_high.rolling(n).max() - ser_low.rolling(n).min())) * 100
#     STOD = STOK.rolling(3).mean()
#     dt_K = pd.Series(STOK).fillna(method='bfill').values
#     dt_D = pd.Series(STOD).fillna(method='bfill').values
#     return dt_K, dt_D
# 
# def Awesome_Oscillator(low, high, period_fast=5, period_slow=34):
#     ser_low = pd.Series(low)
#     ser_high = pd.Series(high)
#     MEDIAN_PRICE = (ser_high+ser_low)/2
#     AO = MEDIAN_PRICE.rolling(period_fast).mean() - MEDIAN_PRICE.rolling(period_slow).mean()
#     ret_AO = pd.Series(AO).fillna(method='bfill').values
#     return ret_AO
# 
# def M_A_C_D(close, period_fast=12, period_slow=26, period_signal=9):
#     ser = pd.Series(close)
#     ema_fast = ser.ewm(span=period_fast, adjust=False).mean()
#     ema_slow = ser.ewm(span=period_slow, adjust=False).mean()
#     MACD_Line = ema_fast - ema_slow
#     Signal_line = MACD_Line.ewm(span=period_signal, adjust=False).mean()
#     MACD_Histogram = MACD_Line - Signal_line
#     ret_MACD_Line = pd.Series(MACD_Line).fillna(method='bfill').values
#     ret_Signal_line = pd.Series(Signal_line).fillna(method='bfill').values
#     ret_MACD_Histogram = pd.Series(MACD_Histogram).fillna(method='bfill').values
#     return ret_MACD_Line, ret_Signal_line, ret_MACD_Histogram
# 
# def A_D_X(high, low, close, period=14):
#     df = pd.DataFrame({'High':high, 'Low':low, 'Close':close})
#     i = 0
#     UpI = []
#     DoI = []
#     while i + 1 <= df.index[-1]: #<=
#         UpMove = df.loc[i + 1, 'High'] - df.loc[i, 'High']
#         DoMove = df.loc[i, 'Low'] - df.loc[i + 1, 'Low']
#         if UpMove > DoMove and UpMove > 0:
#             UpD = UpMove
#         else:
#             UpD = 0
#         UpI.append(UpD)
#         if DoMove > UpMove and DoMove > 0:
#             DoD = DoMove
#         else:
#             DoD = 0
#         DoI.append(DoD)
#         i = i + 1
#     i = 0
#     TR_l = [0]
#     while i < df.index[-1]:
#         TR = max(df.loc[i + 1, 'High'], df.loc[i, 'Close']) - min(df.loc[i + 1, 'Low'], df.loc[i, 'Close'])
#         TR_l.append(TR)
#         i = i + 1
#     TR_s = pd.Series(TR_l)
#     ATR = pd.Series(TR_s.ewm(span=period, min_periods=period).mean())
#     UpI = pd.Series(UpI)
#     DoI = pd.Series(DoI)
#     PosDI = pd.Series(UpI.ewm(span=period, min_periods=period).mean() / ATR)
#     NegDI = pd.Series(DoI.ewm(span=period, min_periods=period).mean() / ATR)
#     ADX = pd.Series((abs(PosDI - NegDI) / (PosDI + NegDI)).ewm(span=period, min_periods=period).mean(),
#                     name='ADX_' + str(period) + '_' + str(period))
#     ADX = pd.Series(ADX*100)
#     PosDI = pd.Series(PosDI*100)
#     NegDI = pd.Series(NegDI*100)
#     return PosDI.values, NegDI.values, ADX.values
# 
# 
# 
# def C_C_I(high, low, close, period=20, constant=0.015):
#     df = pd.DataFrame({'High':high, 'Low':low, 'Close':close})
#     PP = (df['High'] + df['Low'] + df['Close']) / 3
#     CCI = pd.Series((PP - PP.rolling(period, min_periods=period).mean()) / (constant * PP.rolling(period, min_periods=period).std()), name='CCI_' + str(period))
#     return CCI.values
# 
# 
# #symbolName = input("Symbol(BTC, ETH, LTC...vb): ")
# #timeframe = input("timeframe (1m,3m,5m,15m,30m,45m,1h,2h,4h,6h,8h,12h,1d): ")
# timeframe = '30m'
# #symbol = str(symbolName) + "USDT"
# #slowEMAValue = input ("slow Ema: ")
# #fastEMAValue = input ("fast Ema: ")
# #symbol = str(symbolName) + "USDT"
# 
# 
# 
# ANS = []
# dt_close = []
# dt_open = []
# dt_high = []
# dt_low = []
# dt_volume = []
# ohlc_index = 0
# ohlc = []
# smaix = []
# 
# 
# 
# # API CONNECT
# 
# exchange = ccxt.binance({
# "apiKey": '22c265ujwKRUntHzBvxBhhjTQIn9slaReRsqH7MEHySeHkDoN2T61B563nl613Tj',
# "secret": '7ncxADFOxklDlzs2kS2CdGqaiTQWihC5KkPGg6jT8dhrrfYHfTtkl2ym0VsmNdUS',
# 
# 'options': {
# 'defaultType': 'future'
# },
# 'enableRateLimit': True
# })
# 
# while True:
#     try:
#         symbolName = ['GMT','GALA','BTC', 'ETH', 'BNB', 'XRP', 'ADA','SOL','DOT','AVAX','DOGE','MATIC',
#                   'LTC','ATOM','LINK','NEAR','TRX','ALGO','BCH','XLM','FTM','UNI','MANA','HBAR','SAND',
#                   'ETH','AXS','ICP','VET','XTZ','FIL','EGLD','THETA','XMR','KLAY','HNT','GRT','ONE','EOS',
#                   'FLOW','AAVE','MKR','ENJ','AR','XEC','STX','NEO','KSM','ZEC','AMP','RUNE',
#                   'CVX','BAT','CELO','LRC','CRV','ROSE','CHZ','DASH','WAVES','SCRT','SLP','SNX'] 
#         
#        
#      
#         j = 0
#         for i in symbolName:
#             symbol = str(symbolName[j]) + "USDT"
#             
#             newSymbol = symbol
#            
#             j = j+1
#         
# 
#             balance = exchange.fetch_balance()
#            
#             free_balance = exchange.fetch_free_balance()
#             positions = balance['info']['positions']
#             #Backtest Strategy
#             #baixando dados da binance, de BTCBRL iniciando em 14/11/2021 de candles de 1 minuto
#             data = vbt.BinanceData.download(symbol, start='2022-01-01', interval ='30m').get()
# 
#             #selecionando o tipo de preço para calcular os indicacores
#             prices  = data.get('Close')
#             volume = data.get('Volume')
# 
#             #criando variavel do indicador RSI/IFR com o Preço de Fechamento e uma janela de 14 periodos.
#             #indicador= vbt.RSI.run(prices,window=14)
# 
#             #Entrada é se o indicador cruzar o valor do indicador para baixo abaixo de 10 e saida quando houve cruzamento do valor em 50
#             #entries = indicador.rsi_below(0)
#             #exits= indicador.rsi_above(0)
# 
#             #Agora faremos as magicas, informar a biblioteca que vamos usar os preços de fechamentos e as entradas e saídas calculadas. 
#             #Colocando apenas 100 unidades de dinheiro, no caso R$100,00
#             #portfolio = vbt.Portfolio.from_signals(prices, entries, exits, init_cash=100)
# 
#             #Voilá! Vamos ploar o grafico para ver se teriamos ficado ricos.
#             #portfolio.plot().show()
# 
#             #print(portfolio.stats())
# 
#             
#             
#             
#             current_positions = [position for position in positions if float(position['positionAmt']) != 0 and position['symbol'] == newSymbol]
#             position_bilgi = pd.DataFrame(current_positions, columns=["symbol", "entryPrice", "unrealizedProfit", "isolatedWallet", "positionAmt", "positionSide"])
#         
#         #Pozisyonda olup olmadığını kontrol etme
#             if not position_bilgi.empty and position_bilgi["positionAmt"][len(position_bilgi.index) - 1] != 0:
#                inposition = True
#             else: 
#                inposition = False
#                shortposition = False
#                longposition = False
#         
#         # Long pozisyonda mı?
#             if inposition and float(position_bilgi["positionAmt"][len(position_bilgi.index) - 1]) > 0:
#                longposition = True
#                shortposition = False
#         # Short pozisyonda mı?
#             if inposition and float(position_bilgi["positionAmt"][len(position_bilgi.index) - 1]) < 0:
#                shortposition = True
#                longposition = False
#         
#         
#         # LOAD BARS
#             bars = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since = None, limit = 200)        
#             df = pd.DataFrame(bars, columns=["timestamp", "open", "high", "low", "close", "volume"])
#             dt_close = df["close"]
#             dt_open = df["open"]
#             dt_high = df["high"]
#             dt_low = df["low"]
#             dt_volume = df["volume"]
#             dt_ohlc4 =  (dt_close+dt_open+ dt_high+dt_low)/4
# 
#             inputs = {
#               'open': np.random.random(100),
#               'high': np.random.random(100),
#               'low': np.random.random(100),
#               'close': np.random.random(100),
#               'volume': np.random.random(100)
# }         
#             
#             
#             #WILL = WILLR(inputs,14) 
#             WILL = WILLR(dt_high, dt_low, dt_close, timeperiod=14)
#              #print("WILLR   %R = "+str(math.trunc(WILL[-1]))) 
#             linear =LINEARREG_SLOPE(inputs,14)
#             #print("LINEARREG_SLOPE = "+str(math.trunc(linear[-1]*10000)))  
# 
#             sma5 = SMAfunc(dt_close, 5)
#             sma2 = SMAfunc(dt_close, 2)
#             ema2 = EMAfunc(dt_close, 2)
#             ema5 = EMAfunc(dt_close, 5)
#             sma4 = SMAfunc(dt_close, 4)
#             ema4 = EMAfunc(dt_close, 4)
#             rsi = RSIfunc(dt_close, rsi_period=14)           
# 
#             #RSI
#             rsi14 = RSIfunc(dt_close, rsi_period=14)
#             rsi5 = RSIfunc(dt_close, rsi_period=5)
#             rsi6 = RSIfunc(dt_close, rsi_period=6)
#             sum = (rsi14+rsi5+rsi6)/3
#             ema5 = EMAfunc(sum, 5)
#             ema7 = EMAfunc(sum, 7)
#             ema14 = EMAfunc(sum, 14)        
#             sumema = (ema5+ema7+ema14)/3  
#             
#             #CCI
#             cci20 = C_C_I(dt_high, dt_low, dt_close, 20)     # CCI  
#             cci14 = C_C_I(dt_high, dt_low, dt_close, 14)     # CCI 
# 
#             #AO      
#             ret_AO = Awesome_Oscillator(dt_low, dt_high, period_fast=5, period_slow=34)
# 
#             #delta MAXMIN ADX
#             pDI , nDI, aDx14 = A_D_X(dt_high, dt_low, dt_close, 8) # ADX  มี 3 เส้น +DI, -DI, ADX  
#             MAXpDI = MAX(pDI, timeperiod=8)  
#             MINpDI = MIN(pDI, timeperiod=8)  
#             middlepDI = (MAXpDI+MINpDI)/2
#             MAXnDI = MAX(nDI, timeperiod=8)  
#             MINnDI = MIN(nDI, timeperiod=8)  
#             middlenDI = (MAXnDI+MINnDI)/2   
#             deltaADX =  middlepDI- middlenDI 
#             MAXdeltaADX = MAX(deltaADX, timeperiod=8)
#             MINdeltaADX = MIN(deltaADX, timeperiod=8)
#             middledelta = (MAXdeltaADX+MINdeltaADX)/2
#             #delta BB ADX
#             upper,mid,lower = bollinger_band(pDI, bb_period=14, mult=2)
#             upper1,mid1,lower1 = bollinger_band(nDI, bb_period=14, mult=2)            
#             delta = mid-mid1
# 
#             #Stoch
#             dt_K,dt_D = StochOSC(dt_close,dt_low,dt_high,14)
#             dt_K1,dt_D1 = StochOSC(sum,sum,sum,14)
#           
# 
#             #min, max = MINMAX(dt_close, timeperiod=30)
#             #print("price hi= "+str((max[-2])))
#             #print("price lo= "+str((min[-2])))
#             print( newSymbol,"  =  ", float(df["close"][len(df.index)-1]),"USDT")
# 
#            
#             
#             #print("ADX   pDI = "+str(math.trunc(pDI[-2]))+  "   nDI = "+str(math.trunc(nDI[-2]))+ "   aDx14 = "+str(math.trunc(aDx14[-2])))
#             print("deltaADX= "+str((middledelta[-2])))
#             
# 
#             print("Backtest>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ")
# 
#             #Backtest>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#             data = data.copy()
#             #Indicator BB
#             data['Middle Band'] = data['Close'].rolling(window=50).mean()
#             data['Upper Band'] = data['Middle Band'] + 1.96*data['Close'].rolling(window=50).std()
#             data['Lower Band'] = data['Middle Band'] - 1.96*data['Close'].rolling(window=50).std()
#             data.tail(500)[['Middle Band', 'Upper Band', 'Lower Band', 'Close']].plot(figsize=(30, 5))
#             
#             #Indicator ADX
#             adxI = ADXIndicator(data['High'],data['Low'],data['Close'],14,False)
#             data['pos_directional_indicator'] = adxI.adx_pos()
#             data['neg_directional_indicator'] = adxI.adx_neg()
#             data['adx'] = adxI.adx()
#             #data.tail(500)[['pos_directional_indicator','neg_directional_indicator','adx']].plot(figsize=(30, 5))
#             data['trend'] = np.where(data.adx>25,data['Close'],np.nan)
#             data['trend_signal'] = np.where(data.adx>25,1,0)
#             #data.tail(500)[['trend','trend_signal']].plot(figsize=(30, 5))
# 
#             #Indicator BB pos_directional_indicator
#             data['Middle Band'] = data['pos_directional_indicator'].rolling(window=8).mean()
#             data['Upper Band'] = data['Middle Band'] + 1.96*data['pos_directional_indicator'].rolling(window=8).std()
#             data['Lower Band'] = data['Middle Band'] - 1.96*data['pos_directional_indicator'].rolling(window=8).std()
#             #data.tail(500)[['Middle Band', 'Upper Band', 'Lower Band']].plot(figsize=(30, 5))
# 
#             #Indicator BB neg_directional_indicator
#             data['Middle Band1'] = data['neg_directional_indicator'].rolling(window=8).mean()
#             data['Upper Band1'] = data['Middle Band1'] + 1.96*data['neg_directional_indicator'].rolling(window=8).std()
#             data['Lower Band1'] = data['Middle Band1'] - 1.96*data['neg_directional_indicator'].rolling(window=8).std()
#             #data.tail(500)[['Middle Band1', 'Upper Band1', 'Lower Band1']].plot(figsize=(30, 5))
# 
#             # ADX
#             #data.tail(500)[['pos_directional_indicator','neg_directional_indicator','adx','Middle Band', 'Upper Band', 'Lower Band','Middle Band1', 'Upper Band1', 'Lower Band1']].plot(figsize=(30, 5))
#             #data.tail(500)[['pos_directional_indicator','neg_directional_indicator','Middle Band','Middle Band1']].plot(figsize=(30, 5))
#             #Usde Strategy Valve
#             data['Delta ADX'] = data['Middle Band']-data['Middle Band1']            
#             data['0'] =0
#             data['20'] =20 
#             data.tail(500)[['pos_directional_indicator','neg_directional_indicator','Middle Band','Middle Band1','Delta ADX','0']].plot(figsize=(30, 5))
#             st.subheader(f'Symbol is {newSymbol} ')
#             st.subheader(f'Price Market {prices[-1]} ')            
#             
#             st.line_chart(prices)
#             st.subheader(f'Volume {volume[-1]} ')  
#             st.line_chart(volume)
#             st.subheader('Delta ADX')          
#             
#             st.line_chart(data.tail(500)[['pos_directional_indicator','neg_directional_indicator','Middle Band','Middle Band1','Delta ADX','0']])
#             print("deltaADX1= "+str((data['Delta ADX'][-2])))
# 
#             window = 41
#             lag = 41
#             sl = 0.01
#             tp = 0.01
#             tr = 0.01
#             
#             #BB Straregy
#             data['Middle Band'] = data['Close'].rolling(
#                 window=window).mean()
#             data['Upper Band'] = data['Middle Band'] + \
#                 1.96*data['Close'].rolling(window=window).std()
#             data['Lower Band'] = data['Middle Band'] - \
#                 1.96*data['Close'].rolling(window=window).std()
# 
# 
#             #data['entries_long'] = np.where(
#                 #data['Close'] < data['Lower Band'], True, False)
#             #data['exits_long'] = np.where(
#                 #data['entries_long'].shift(lag), True, False)
#             #data['entries_short'] = np.where(
#                 #data['Close'] > data['Upper Band'], True, False)
#             #data['exits_short'] = np.where(
#                 #data['entries_short'].shift(lag), True, False)
#             ##BB Straregy
# 
#             ## ADX Strategy
#             data['entries_long'] = np.where(
#                 data['Delta ADX'] > data['0'] , True, False)
#             data['exits_long'] = np.where(
#                 data['entries_long'].shift(lag), True, False)
#             data['entries_short'] = np.where(
#                 data['Delta ADX'] < data['0'] , True, False)   #data['Delta ADX'] < data['0'] , True, False)
#             data['exits_short'] = np.where(
#                 data['entries_short'].shift(lag), True, False)
# 
# 
#     
#             
#             
#             pf = vbt.Portfolio.from_signals(
#                 sl_stop=sl,
#                 tp_stop=tp,
#                 sl_trail=tr,
#                 close=data['Close'],
#                 entries=data['entries_long'],
#                 exits=data['exits_long'],
#                 short_entries=data['entries_short'],
#                 short_exits=data['exits_short'],
#                 direction='both',
#                 accumulate=True
#             )
#            
#             #portfolio = vbt.Portfolio.from_signals(data['Close'], entries, exits, init_cash=100)
# 
#             #Voilá! Vamos ploar o grafico para ver se teriamos ficado ricos.
#             
#             pf.plot().show()
#        
#             print(pf.stats())
#            
#             st.subheader(f'Backtest {newSymbol} ')
#             st.subheader(f'Backtest {pf.stats()} ')
#           
#             
#              
#         
#             print("End Backtest>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ")
#             #End Backtest>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#             
#             
# 
# 
# 
#             #PLOT Candle        
#             plt.figure(figsize=(12.4, 4.5))
#             #define width of candlestick elements
#             width = 1
#             width2 = .09
#             #define up and down prices
#             up = df[df.close>=df.open]
#             down = df[df.close<df.open]
#             #define colors to use
#             col1 = 'green'
#             col2 = 'red'
#             #plot up prices
#             plt.bar(up.index,up.close-up.open,width,bottom=up.open,color=col1)
#             plt.bar(up.index,up.high-up.close,width2,bottom=up.close,color=col1)
#             plt.bar(up.index,up.low-up.open,width2,bottom=up.open,color=col1)
#             
#             
#             #plot down prices
#             plt.bar(down.index,down.close-down.open,width,bottom=down.open,color=col2)
#             plt.bar(down.index,down.high-down.open,width2,bottom=down.open,color=col2)
#             plt.bar(down.index,down.low-down.close,width2,bottom=down.close,color=col2)
#             
#             #rotate x-axis tick labels
#             plt.xticks(rotation=0, ha='right')
#             #display candlestick chart
#             upper,mid,lower = bollinger_band(dt_close, bb_period=14, mult=2)
#             MAXcandle = MAX(dt_high, timeperiod=8)  
#             MINcandle = MIN(dt_low, timeperiod=8)
#             midlecandle = (MAXcandle+MINcandle)/2
#             
#             plt.plot(MAXcandle, color='green')
#             plt.plot(midlecandle, color='black')
#             plt.plot(MINcandle, color='red')
#            
#             plt.plot(upper,'--')
#             plt.plot(mid,'--')
#             plt.plot(lower,'--')
#             plt.title("Chart Candle")
#             plt.ylabel("Candle Values")
#             plt.legend(loc="upper left")       
#             plt.show()
# 
#             # delta  ADX
#             plt.figure(figsize=(12.4, 4.5))
#             pDI , nDI, aDx14 = A_D_X(dt_high, dt_low, dt_close, 8) # ADX  มี 3 เส้น +DI, -DI, ADX  
#             MAXpDI = MAX(pDI, timeperiod=8)  
#             MINpDI = MIN(pDI, timeperiod=8)  
#             middlepDI = (MAXpDI+MINpDI)/2
#             MAXnDI = MAX(nDI, timeperiod=8)  
#             MINnDI = MIN(nDI, timeperiod=8)  
#             middlenDI = (MAXnDI+MINnDI)/2   
#             deltaADX =  middlepDI- middlenDI 
#             MAXdeltaADX = MAX(deltaADX, timeperiod=8)
#             MINdeltaADX = MIN(deltaADX, timeperiod=8)
#             middledelta = (MAXdeltaADX+MINdeltaADX)/2             
#             plt.plot( pDI, color='green')
#             plt.plot( nDI, color='red') 
#             plt.plot(middlepDI,'--')
#             plt.plot(middlenDI,'--')
#             #plt.bar(range(20, len(dt_close)),deltaADX[20:],color='yellow',label="deltaADX")
#             plt.bar(range(20, len(dt_close)),middledelta[20:],color='green',label="ADXCross")
#             plt.axhline(25, linestyle="--", color="orange")
#             plt.title("deltaADX")
#             plt.ylabel("ADX Values")
#             plt.legend(loc="upper left")
#             plt.show()
# 
#             #delta BB ADX
#             plt.figure(figsize=(12.4, 4.5))
#             upper,mid,lower = bollinger_band(pDI, bb_period=14, mult=2)
#             upper1,mid1,lower1 = bollinger_band(nDI, bb_period=14, mult=2)            
#             delta = mid-mid1
#             plt.plot( pDI, color='green')
#             plt.plot( nDI, color='red') 
#             plt.plot(mid,'--')
#             plt.plot(mid1,'--')
#             #plt.bar(range(20, len(dt_close)),deltaADX[20:],color='yellow',label="deltaADX")
#             plt.bar(range(20, len(dt_close)),delta[20:],color='green',label="ADXCross")
#             plt.axhline(25, linestyle="--", color="orange")
#             plt.title("deltaADX")
#             plt.ylabel("ADX Values")
#             plt.legend(loc="upper left")
#             plt.show()
# 
#             
# 
# 
# 
#             #MACD
#             plt.figure(figsize=(12.4, 4.5))
#             macd, macdsignal, macdhist = MACD(dt_close, fastperiod=12, slowperiod=26, signalperiod=9)
#             plt.plot(range(20, len(dt_close)),macd[20:],color='green',label="MACD_Line")
#             plt.plot(range(20, len(dt_close)),macdsignal[20:],color='black',label="Signal_line")
#             plt.bar(range(20, len(dt_close)),macdhist[20:],color='yellow',label="MACD_Histogram")                
#             plt.title('MACD')
#             plt.ylabel("MACD Values")
#             plt.legend(loc="upper left")       
#             plt.show()
# 
#             #RSI
#             plt.figure(figsize=(12.4, 4.5))
#             rsi14 = RSIfunc(dt_close, rsi_period=14)
#             rsi15 = RSIfunc(delta, rsi_period=14)
#             rsi5 = RSIfunc(dt_close, rsi_period=5)
#             rsi6 = RSIfunc(dt_close, rsi_period=6)
#             sum = (rsi14+rsi5+rsi6)/3
#             ema2 = EMAfunc(sum, 2) 
#             emadelta = EMAfunc(rsi15, 5)            
#             plt.plot(sum,label = 'sumrsi')
#             plt.plot(ema2,label = 'emarsi2')
#             plt.plot(rsi15,label = 'rsidelta')
#             plt.title('RSI')
#             upper,mid,lower = bollinger_band(sum, bb_period=14, mult=2)
#             #plt.plot(upper,'--')
#             plt.plot(mid,'--')
#             #plt.plot(lower,'--')
#             upper1,mid1,lower1 = bollinger_band(rsi15, bb_period=14, mult=1)
#             #plt.plot(upper1,'--')
#             plt.plot(emadelta,color="green")
#             delta = rsi15-emadelta
#             plt.bar(range(20, len(dt_close)),delta[20:],color='yellow',label="RSIdelta")
#             #plt.plot(lower1,'--')
#             plt.axhline(40, linestyle="--", color="red")
#             #plt.axhline(25, linestyle="--", color="blue")
#             #plt.axhline(75, linestyle="--", color="blue")
#             plt.axhline(60, linestyle="--", color="green")
#             plt.ylabel("RSI Values")
#             plt.legend(loc="upper left")
#             plt.show()
# 
# 
#             # PPO - Percentage Price Oscillator 
#             plt.figure(figsize=(12.4, 4.5)) 
#             pro = PPO(dt_close, fastperiod=12, slowperiod=26, matype=0)
#             plt.bar(range(20, len(dt_close)),pro[20:],color="green",label="Percentage Price Oscillator")
#             st.subheader('Percentage Price Oscillator')
#             
#             #st.write(data.tail(500)[['pos_directional_indicator','neg_directional_indicator','Middle Band','Middle Band1','Delta ADX','0']])
#             st.line_chart(pro)
#                    
#             plt.axhline(0, linestyle="--", color="orange")       
#             plt.title("Percentage Price Oscillator")
#             plt.ylabel("Percentage Price Oscillator Values")
#             plt.legend(loc="upper left")
#             plt.show() 
# 
#             # ADX cross
#             #plt.figure(figsize=(12.4, 4.5))
#             #upper,mid,lower = bollinger_band(pDI, bb_period=14, mult=2)
#             #upper1,mid1,lower1 = bollinger_band(nDI, bb_period=14, mult=2)        
#             
#             #plt.plot( pDI, color='green')
#             #plt.plot( nDI, color='red') 
#             #plt.plot(mid,'--')
#             #plt.plot(mid1,'--')
#             #delta = mid-mid1
#             #plt.bar(range(20, len(dt_close)),delta[20:],color='yellow',label="ADXCross")
#             #plt.axhline(25, linestyle="--", color="orange")
#             #plt.title("ADX down")
#             #plt.ylabel("ADX Values")
#             #plt.legend(loc="upper left")
#             #plt.show()
# 
#             
# 
# 
#             # ROC - Rate of change : ((price/prevPrice)-1)*100
#             #plt.figure(figsize=(12.4, 4.5)) 
#             #roc = ROC(dt_close, timeperiod=14)
#             #plt.bar(range(20, len(dt_close)),roc[20:],color="green",label="Rate of change")        
#             #plt.axhline(0, linestyle="--", color="orange")       
#             #plt.title("Rate of change")
#             #plt.ylabel("Rate of change Values")
#             #plt.legend(loc="upper left")
#             #plt.show()
#              
#             
#           
# 
#         
#     except ccxt.BaseError as Error:
#         print ("[ERROR] ", Error )
#         continue
#

!streamlit run app.py & npx localtunnel --port 8501

# Commented out IPython magic to ensure Python compatibility.
# # # This app is for educational purpose only. Insights gained is not financial advice. Use at your own risk!
# %%writefile app1.py
# import streamlit as st
# from PIL import Image
# import pandas as pd
# import base64
# import matplotlib.pyplot as plt
# from bs4 import BeautifulSoup
# import requests
# import json
# import time
# #---------------------------------#
# # New feature (make sure to upgrade your streamlit library)
# # pip install --upgrade streamlit
# 
# #---------------------------------#
# # Page layout
# ## Page expands to full width
# st.set_page_config(layout="wide") #st.beta_set_page_config(layout="wide")
# #---------------------------------#
# # Title
# 
# image = Image.open('/content/logo.jpg')
# 
# st.image(image, width = 500)
# 
# st.title('Crypto Price App')
# st.markdown("""
# This app retrieves cryptocurrency prices for the top 100 cryptocurrency from the **CoinMarketCap**!
# """)
# #---------------------------------#
# # About
# expander_bar = st.beta_expander("About")
# expander_bar.markdown("""
# * **Python libraries:** base64, pandas, streamlit, numpy, matplotlib, seaborn, BeautifulSoup, requests, json, time
# * **Data source:** [CoinMarketCap](http://coinmarketcap.com).
# * **Credit:** Web scraper adapted from the Medium article *[Web Scraping Crypto Prices With Python](https://towardsdatascience.com/web-scraping-crypto-prices-with-python-41072ea5b5bf)* written by [Bryan Feng](https://medium.com/@bryanf).
# """)
# 
# 
# #---------------------------------#
# # Page layout (continued)
# ## Divide page to 3 columns (col1 = sidebar, col2 and col3 = page contents)
# col1 = st.sidebar
# col2, col3 = st.beta_columns((2,1))
# 
# #---------------------------------#
# # Sidebar + Main panel
# col1.header('Input Options')
# 
# ## Sidebar - Currency price unit
# currency_price_unit = col1.selectbox('Select currency for price', ('USD', 'BTC', 'ETH'))
# 
# # Web scraping of CoinMarketCap data
# @st.cache
# def load_data():
#     cmc = requests.get('https://coinmarketcap.com')
#     soup = BeautifulSoup(cmc.content, 'html.parser')
# 
#     data = soup.find('script', id='__NEXT_DATA__', type='application/json')
#     coins = {}
#     coin_data = json.loads(data.contents[0])
#     listings = coin_data['props']['initialState']['cryptocurrency']['listingLatest']['data']
#     for i in listings:
#       coins[str(i['id'])] = i['slug']
# 
#     coin_name = []
#     coin_symbol = []
#     market_cap = []
#     percent_change_1h = []
#     percent_change_24h = []
#     percent_change_7d = []
#     price = []
#     volume_24h = []
# 
#     for i in listings:
#       coin_name.append(i['slug'])
#       coin_symbol.append(i['symbol'])
#       price.append(i['quote'][currency_price_unit]['price'])
#       percent_change_1h.append(i['quote'][currency_price_unit]['percentChange1h']) # percent_change_1h
#       percent_change_24h.append(i['quote'][currency_price_unit]['percentChange24h']) #percent_change_24h
#       percent_change_7d.append(i['quote'][currency_price_unit]['percentChange7d']) # percent_change_7d
#       market_cap.append(i['quote'][currency_price_unit]['marketCap']) # market_cap
#       volume_24h.append(i['quote'][currency_price_unit]['volume24h']) # volume_24h
# 
#     df = pd.DataFrame(columns=['coin_name', 'coin_symbol', 'marketCap', 'percentChange1h', 'percentChange24h', 'percentChange7d', 'price', 'volume24h'])
#     df['coin_name'] = coin_name
#     df['coin_symbol'] = coin_symbol
#     df['price'] = price
#     df['percentChange1h'] = percent_change_1h
#     df['percentChange24h'] = percent_change_24h
#     df['percentChange7d'] = percent_change_7d
#     df['marketCap'] = market_cap
#     df['volume24h'] = volume_24h
#     return df
# 
# df = load_data()
# 
# ## Sidebar - Cryptocurrency selections
# sorted_coin = sorted( df['coin_symbol'] )
# selected_coin = col1.multiselect('Cryptocurrency', sorted_coin, sorted_coin)
# 
# df_selected_coin = df[ (df['coin_symbol'].isin(selected_coin)) ] # Filtering data
# 
# ## Sidebar - Number of coins to display
# num_coin = col1.slider('Display Top N Coins', 1, 100, 100)
# df_coins = df_selected_coin[:num_coin]
# 
# ## Sidebar - Percent change timeframe
# percent_timeframe = col1.selectbox('Percent change time frame',
#                                     ['7d','24h', '1h'])
# percent_dict = {"7d":'percentChange7d',"24h":'percentChange24h',"1h":'percentChange1h'}
# selected_percent_timeframe = percent_dict[percent_timeframe]
# 
# ## Sidebar - Sorting values
# sort_values = col1.selectbox('Sort values?', ['Yes', 'No'])
# 
# col2.subheader('Price Data of Selected Cryptocurrency')
# col2.write('Data Dimension: ' + str(df_selected_coin.shape[0]) + ' rows and ' + str(df_selected_coin.shape[1]) + ' columns.')
# 
# col2.dataframe(df_coins)
# 
# # Download CSV data
# # https://discuss.streamlit.io/t/how-to-download-file-in-streamlit/1806
# def filedownload(df):
#     csv = df.to_csv(index=False)
#     b64 = base64.b64encode(csv.encode()).decode()  # strings <-> bytes conversions
#     href = f'<a href="data:file/csv;base64,{b64}" download="crypto.csv">Download CSV File</a>'
#     return href
# 
# col2.markdown(filedownload(df_selected_coin), unsafe_allow_html=True)
# 
# #---------------------------------#
# # Preparing data for Bar plot of % Price change
# col2.subheader('Table of % Price Change')
# df_change = pd.concat([df_coins.coin_symbol, df_coins.percentChange1h, df_coins.percentChange24h, df_coins.percentChange7d], axis=1)
# df_change = df_change.set_index('coin_symbol')
# df_change['positive_percent_change_1h'] = df_change['percentChange1h'] > 0
# df_change['positive_percent_change_24h'] = df_change['percentChange24h'] > 0
# df_change['positive_percent_change_7d'] = df_change['percentChange7d'] > 0
# col2.dataframe(df_change)
# 
# # Conditional creation of Bar plot (time frame)
# col3.subheader('Bar plot of % Price Change')
# 
# if percent_timeframe == '7d':
#     if sort_values == 'Yes':
#         df_change = df_change.sort_values(by=['percentChange7d'])
#     col3.write('*7 days period*')
#     plt.figure(figsize=(5,25))
#     plt.subplots_adjust(top = 1, bottom = 0)
#     df_change['percentChange7d'].plot(kind='barh', color=df_change.positive_percent_change_7d.map({True: 'g', False: 'r'}))
#     col3.pyplot(plt)
# elif percent_timeframe == '24h':
#     if sort_values == 'Yes':
#         df_change = df_change.sort_values(by=['percentChange24h'])
#     col3.write('*24 hour period*')
#     plt.figure(figsize=(5,25))
#     plt.subplots_adjust(top = 1, bottom = 0)
#     df_change['percentChange24h'].plot(kind='barh', color=df_change.positive_percent_change_24h.map({True: 'g', False: 'r'}))
#     col3.pyplot(plt)
# else:
#     if sort_values == 'Yes':
#         df_change = df_change.sort_values(by=['percentChange1h'])
#     col3.write('*1 hour period*')
#     plt.figure(figsize=(5,25))
#     plt.subplots_adjust(top = 1, bottom = 0)
#     df_change['percentChange1h'].plot(kind='barh', color=df_change.positive_percent_change_1h.map({True: 'g', False: 'r'}))
#     col3.pyplot(plt)

!streamlit run app1.py & npx localtunnel --port 8501